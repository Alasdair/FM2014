
@article{hoare_concurrent_2011,
	title = {Concurrent Kleene Algebra and its Foundations},
	volume = {80},
	number = {6},
	journal = {J. Log. Algebr. Program.},
	author = {Hoare, T. and M{\"o}ller, B. and Struth, G. and Wehrman, I.},
	year = {2011},
	pages = {266{\textendash}296}
},

@article{kozen_completeness_1994,
	title = {A Completeness Theorem for Kleene Algebras and the Algebra of Regular Events},
	volume = {110},
	number = {2},
	journal = {Information and Computation},
	author = {Kozen, D.},
	year = {1994},
	pages = {366{\textendash}390}
},

@article{kozen_kleene_1997,
	title = {Kleene Algebra with Tests},
	volume = {19},
	number = {3},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Kozen, D.},
	year = {1997},
	pages = {427{\textendash}443}
},

@book{nipkow_isabelle/hol:_2002,
	series = {{LNCS}},
	title = {{Isabelle/HOL:} A Proof Assistant for Higher-Order Logic},
	volume = {2283},
	publisher = {Springer},
	author = {Nipkow, T. and Paulson, L. C. and Wenzel, M.},
	year = {2002}
},

@article{armstrong_kleene_2013,
	title = {Kleene Algebra},
	volume = {2013},
	url = {http://dblp.uni-trier.de/rec/bibtex/journals/afp/ArmstrongSW13},
	urldate = {2013-10-01},
	journal = {Archive of Formal Proofs},
	author = {Armstrong, A and Struth, G and Weber, T},
	year = {2013}
},

@incollection{blanchette_nitpick:_2010,
	series = {Lecture Notes in Computer Science},
	title = {Nitpick: A Counterexample Generator for Higher-Order Logic Based on a Relational Model Finder},
	copyright = {{\textcopyright}2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-14051-8, 978-3-642-14052-5},
	shorttitle = {Nitpick},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-14052-5_11},
	abstract = {Nitpick is a counterexample generator for {Isabelle/HOL} that builds on Kodkod, a {SAT-based} first-order relational model finder. Nitpick supports unbounded quantification, (co)inductive predicates and datatypes, and (co)recursive functions. Fundamentally a finite model finder, it approximates infinite types by finite subsets. As case studies, we consider a security type system and a hotel key card system. Our experimental results on Isabelle theories and the {TPTP} library indicate that Nitpick generates more counterexamples than other model finders for higher-order logic, without restrictions on the form of the formulas to falsify.},
	number = {6172},
	urldate = {2013-10-03},
	booktitle = {Interactive Theorem Proving},
	publisher = {Springer Berlin Heidelberg},
	author = {Blanchette, Jasmin Christian and Nipkow, Tobias},
	editor = {Kaufmann, Matt and Paulson, Lawrence C.},
	month = jan,
	year = {2010},
	keywords = {Antibodies, Artificial Intelligence (incl. Robotics), Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {131--146},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/GZR8HX7V/Blanchette and Nipkow - 2010 - Nitpick A Counterexample Generator for Higher-Ord.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/HVM9RVZI/10.html:text/html}
},

@inproceedings{brookes_full_1993,
	title = {Full abstraction for a shared variable parallel language},
	abstract = {We give a new denotational semantics for a shared variable parallel programming language and prove full abstraction: the semantics gives identical meanings to commands if and only if they induce the same partial correctness behavior in all program contexts. The meaning of a command is a set of {\textquotedblleft}transition traces{\textquotedblright}, which record the ways in which a command may interact with and be affected by its environment. We show how to modify the semantics to incorporate new program constructs, to allow for different levels of granularity or atomicity, and to model fair infinite computation, in each case achieving full abstraction with respect to an appropriate notion of program behavior. 1},
	booktitle = {In Proceedings, 8th Annual {IEEE} Symposium on Logic in Computer Science},
	publisher = {{IEEE} Computer Society Press},
	author = {Brookes, Stephen},
	year = {1993},
	pages = {98{\textendash}109},
	file = {Citeseer - Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/KBVWQQCR/Brookes - 1993 - Full abstraction for a shared variable parallel la.pdf:application/pdf;Citeseer - Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/TVH97QJH/summary.html:text/html}
},

@article{dingel_refinement_2002,
	title = {A Refinement Calculus for Shared-Variable Parallel and Distributed Programming},
	volume = {14},
	issn = {0934-5043, 1433-{299X}},
	url = {http://link.springer.com/article/10.1007/s001650200032},
	doi = {10.1007/s001650200032},
	abstract = {Parallel computers have not yet had the expected impact on mainstream computing. Parallelism adds a level of complexity to the programming task that makes it very error-prone. Moreover, a large variety of very different parallel architectures exists. Porting an implementation from one machine to another may require substantial changes. This paper addresses some of these problems by developing a formal basis for the design of parallel programs in the form of a refinement calculus. The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification. The calculus thus helps structuring and documenting the development process. Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree. Development efforts above this point in the tree are independent of that feature and are thus reusable. Moreover, the discovery of new, possibly more efficient solutions is facilitated. Last but not least, programs are correct by construction, which obviates the need for difficult debugging. Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels. The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly. The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality. The calculus straddles both concurrency paradigms, that is, a shared-variable program can be refined into a distributed, message-passing program and vice versa.},
	language = {en},
	number = {2},
	urldate = {2013-10-03},
	journal = {Formal Aspects of Computing},
	author = {Dingel, J.},
	month = dec,
	year = {2002},
	keywords = {Keywords: Assumption-commitment reasoning; Formal program development; Parallel programming; Program transformation; Refinement; Refinement calculus; Systematic programming; Trace semantics},
	pages = {123--197},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/4XDNQRVM/Dingel - 2002 - A Refinement Calculus for Shared-Variable Parallel.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/S7H2FTDB/10.html:text/html}
}