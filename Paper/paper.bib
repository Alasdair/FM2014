
@inproceedings{kozen_certification_2000,
	title = {Certification of compiler optimizations using Kleene algebra with tests},
	abstract = {We use Kleene algebra with tests to verify a wide assortment ofcommon compiler optimizations, including dead code elimination, common subexpression elimination, copy propagation, loop hoisting, induction variable elimination, instruction scheduling, algebraic simplification, loop unrolling, elimination of redundant instructions, array bounds check elimination, and introduction of sentinels. In each of these cases, we give a formal equational proof of the correctness of the optimizing transformation.},
	booktitle = {{STUCKEY} ({EDS.)}, {PROC.} {RST} {INTERNAT.} {CONF.} {COMPUTATIONAL} {LOGIC} ({CL2000)}, {LECTURE} {NOTES} {IN} {ARTI} {CIAL} {INTELLIGENCE}},
	publisher = {Springer},
	author = {Kozen, Dexter and Patron, Maria-Cristina},
	year = {2000},
	pages = {568{\textendash}582},
	file = {Citeseer - Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/8AU2KZDD/summary.html:text/html}
},

@article{hoare_concurrent_2011,
	title = {Concurrent Kleene Algebra and its Foundations},
	volume = {80},
	number = {6},
	journal = {J. Log. Algebr. Program.},
	author = {Hoare, T. and M{\"o}ller, B. and Struth, G. and Wehrman, I.},
	year = {2011},
	pages = {266{\textendash}296}
},

@article{kozen_completeness_1994,
	title = {A Completeness Theorem for Kleene Algebras and the Algebra of Regular Events},
	volume = {110},
	number = {2},
	journal = {Information and Computation},
	author = {Kozen, D.},
	year = {1994},
	pages = {366{\textendash}390}
},

@article{kozen_kleene_1997,
	title = {Kleene Algebra with Tests},
	volume = {19},
	number = {3},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Kozen, D.},
	year = {1997},
	pages = {427{\textendash}443}
},

@book{nipkow_isabelle/hol:_2002,
	series = {{LNCS}},
	title = {{Isabelle/HOL:} A Proof Assistant for Higher-Order Logic},
	volume = {2283},
	publisher = {Springer},
	author = {Nipkow, T. and Paulson, L. C. and Wenzel, M.},
	year = {2002}
},

@inproceedings{pratt_action_1990,
	series = {{LNCS}},
	title = {Action Logic and Pure Induction},
	volume = {478},
	booktitle = {{JELIA} '90},
	publisher = {Springer},
	author = {Pratt, V. R.},
	editor = {van Eijck, J.},
	year = {1990},
	pages = {97{\textendash}120}
},

@article{armstrong_kleene_2013,
	title = {Kleene Algebra},
	volume = {2013},
	url = {http://dblp.uni-trier.de/rec/bibtex/journals/afp/ArmstrongSW13},
	urldate = {2013-10-01},
	journal = {Archive of Formal Proofs},
	author = {Armstrong, A and Struth, G and Weber, T},
	year = {2013}
},

@incollection{blanchette_nitpick:_2010,
	series = {Lecture Notes in Computer Science},
	title = {Nitpick: A Counterexample Generator for Higher-Order Logic Based on a Relational Model Finder},
	copyright = {{\textcopyright}2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-14051-8, 978-3-642-14052-5},
	shorttitle = {Nitpick},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-14052-5_11},
	abstract = {Nitpick is a counterexample generator for {Isabelle/HOL} that builds on Kodkod, a {SAT-based} first-order relational model finder. Nitpick supports unbounded quantification, (co)inductive predicates and datatypes, and (co)recursive functions. Fundamentally a finite model finder, it approximates infinite types by finite subsets. As case studies, we consider a security type system and a hotel key card system. Our experimental results on Isabelle theories and the {TPTP} library indicate that Nitpick generates more counterexamples than other model finders for higher-order logic, without restrictions on the form of the formulas to falsify.},
	number = {6172},
	urldate = {2013-10-03},
	booktitle = {Interactive Theorem Proving},
	publisher = {Springer Berlin Heidelberg},
	author = {Blanchette, Jasmin Christian and Nipkow, Tobias},
	editor = {Kaufmann, Matt and Paulson, Lawrence C.},
	month = jan,
	year = {2010},
	keywords = {Antibodies, Artificial Intelligence (incl. Robotics), Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {131--146},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/GZR8HX7V/Blanchette and Nipkow - 2010 - Nitpick A Counterexample Generator for Higher-Ord.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/HVM9RVZI/10.html:text/html}
},

@inproceedings{brookes_full_1993,
	title = {Full abstraction for a shared variable parallel language},
	abstract = {We give a new denotational semantics for a shared variable parallel programming language and prove full abstraction: the semantics gives identical meanings to commands if and only if they induce the same partial correctness behavior in all program contexts. The meaning of a command is a set of {\textquotedblleft}transition traces{\textquotedblright}, which record the ways in which a command may interact with and be affected by its environment. We show how to modify the semantics to incorporate new program constructs, to allow for different levels of granularity or atomicity, and to model fair infinite computation, in each case achieving full abstraction with respect to an appropriate notion of program behavior. 1},
	booktitle = {In Proceedings, 8th Annual {IEEE} Symposium on Logic in Computer Science},
	publisher = {{IEEE} Computer Society Press},
	author = {Brookes, Stephen},
	year = {1993},
	pages = {98{\textendash}109},
	file = {Citeseer - Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/KBVWQQCR/Brookes - 1993 - Full abstraction for a shared variable parallel la.pdf:application/pdf;Citeseer - Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/TVH97QJH/summary.html:text/html}
},

@article{dingel_refinement_2002,
	title = {A Refinement Calculus for Shared-Variable Parallel and Distributed Programming},
	volume = {14},
	issn = {0934-5043, 1433-{299X}},
	url = {http://link.springer.com/article/10.1007/s001650200032},
	doi = {10.1007/s001650200032},
	abstract = {Parallel computers have not yet had the expected impact on mainstream computing. Parallelism adds a level of complexity to the programming task that makes it very error-prone. Moreover, a large variety of very different parallel architectures exists. Porting an implementation from one machine to another may require substantial changes. This paper addresses some of these problems by developing a formal basis for the design of parallel programs in the form of a refinement calculus. The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification. The calculus thus helps structuring and documenting the development process. Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree. Development efforts above this point in the tree are independent of that feature and are thus reusable. Moreover, the discovery of new, possibly more efficient solutions is facilitated. Last but not least, programs are correct by construction, which obviates the need for difficult debugging. Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels. The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly. The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality. The calculus straddles both concurrency paradigms, that is, a shared-variable program can be refined into a distributed, message-passing program and vice versa.},
	language = {en},
	number = {2},
	urldate = {2013-10-03},
	journal = {Formal Aspects of Computing},
	author = {Dingel, J.},
	month = dec,
	year = {2002},
	keywords = {Keywords: Assumption-commitment reasoning; Formal program development; Parallel programming; Program transformation; Refinement; Refinement calculus; Systematic programming; Trace semantics},
	pages = {123--197},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/4XDNQRVM/Dingel - 2002 - A Refinement Calculus for Shared-Variable Parallel.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/S7H2FTDB/10.html:text/html}
},

@incollection{boer_formal_1999,
	series = {Lecture Notes in Computer Science},
	title = {Formal justification of the rely-guarantee paradigm for shared-variable concurrency: a semantic approach},
	copyright = {{\textcopyright}1999 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-66588-5, 978-3-540-48118-8},
	shorttitle = {Formal justification of the rely-guarantee paradigm for shared-variable concurrency},
	url = {http://link.springer.com/chapter/10.1007/3-540-48118-4_16},
	abstract = {This paper introduces a semantic analysis of the Rely-Guarantee (R-G) approach to the compositional verification of shared-variable concurrency. The main contribution is a new completeness proof.},
	language = {en},
	number = {1709},
	urldate = {2013-10-04},
	booktitle = {{FM{\textquoteright}99} {\textemdash} Formal Methods},
	publisher = {Springer Berlin Heidelberg},
	author = {Boer, F. S. de and Hannemann, U. and Roever, W.-P. de},
	editor = {Wing, Jeannette M. and Woodcock, Jim and Davies, Jim},
	month = jan,
	year = {1999},
	keywords = {Logics and Meanings of Programs, Programming Languages, Compilers, Interpreters, Software Engineering, Special Purpose and Application-Based Systems},
	pages = {1245--1265},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/BTU9VHDJ/Boer et al. - 1999 - Formal justification of the rely-guarantee paradig.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/HM54GK59/10.html:text/html}
},

@incollection{hoare_locality_2011,
	series = {Lecture Notes in Computer Science},
	title = {On Locality and the Exchange Law for Concurrent Processes},
	copyright = {{\textcopyright}2011 Springer-Verlag {GmbH} Berlin Heidelberg},
	isbn = {978-3-642-23216-9, 978-3-642-23217-6},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-23217-6_17},
	abstract = {This paper studies algebraic models for concurrency, in light of recent work on Concurrent Kleene Algebra and Separation Logic. It establishes a strong connection between the Concurrency and Frame Rules of Separation Logic and a variant of the exchange law of Category Theory. We investigate two standard models: one uses sets of traces, and the other is state-based, using assertions and weakest preconditions. We relate the latter to standard models of the heap as a partial function. We exploit the power of algebra to unify models and classify their variations.},
	number = {6901},
	urldate = {2013-10-08},
	booktitle = {{CONCUR} 2011 {\textendash} Concurrency Theory},
	publisher = {Springer Berlin Heidelberg},
	author = {Hoare, C. a. R. and Hussain, Akbar and M{\"o}ller, Bernhard and {O{\textquoteright}Hearn}, Peter W. and Petersen, Rasmus Lerchedahl and Struth, Georg},
	editor = {Katoen, Joost-Pieter and K{\"o}nig, Barbara},
	month = jan,
	year = {2011},
	keywords = {Artificial Intelligence (incl. Robotics), Computer Communication Networks, Information Systems Applications ({incl.Internet)}, Logics and Meanings of Programs, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {250--264},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/FJDM37V9/Hoare et al. - 2011 - On Locality and the Exchange Law for Concurrent Pr.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/5HVVSTHD/10.html:text/html}
},

@incollection{moller_lazy_2004,
	series = {Lecture Notes in Computer Science},
	title = {Lazy Kleene Algebra},
	copyright = {{\textcopyright}2004 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-22380-1, 978-3-540-27764-4},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-27764-4_14},
	abstract = {We propose a relaxation of Kleene algebra by giving up strictness and right-distributivity of composition. This allows the subsumption of Dijkstra{\textquoteright}s computation calculus, Cohen{\textquoteright}s omega algebra and von Wright{\textquoteright}s demonic refinement algebra. Moreover, by adding domain and codomain operators we can also incorporate modal operators. Finally, it is shown that predicate transformers form lazy Kleene algebras again, the disjunctive and conjunctive ones even lazy Kleene algebras with an omega operation.},
	number = {3125},
	urldate = {2013-10-09},
	booktitle = {Mathematics of Program Construction},
	publisher = {Springer Berlin Heidelberg},
	author = {M{\"o}ller, Bernhard},
	editor = {Kozen, Dexter},
	month = jan,
	year = {2004},
	keywords = {Computation by Abstract Devices, Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Software Engineering},
	pages = {252--273},
	file = {Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/N3NB9THZ/M{\"o}ller - 2004 - Lazy Kleene Algebra.pdf:application/pdf;Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/G9CK88HN/10.html:text/html}
},

@book{wing_fm99_1999,
	title = {{FM'99} - Formal Methods: World Congress on Formal Methods in the Development of Computing Systems, Toulouse, France, September 20-24, 1999 Proceedings},
	isbn = {9783540665885},
	shorttitle = {{FM'99} - Formal Methods},
	abstract = {This book constitutes, together with its compagnion {LNCS} 1708, the refereed proceedings of the World Congress on Formal Methods in the Development of Computing Systems, {FM'99}, held in Toulouse, France in September 1999. The 92 revised full papers presented in the two volumes were carefully reviewed and selected from a total of 259 paper submissions from 35 different countries. Also included are 15 abstracts describing work in progress and industrial applications. The papers are organized in topical sections. This volume contains the following sections: foundations of system specification ({IFIP} {WG} 1.3); European Theory and Practice of Software ({ETAPS);} program verification; integration of notation and techniques; formal description of programming concepts ({IFIP} {WG} 2.2); open information systems; co-design; refinement; safety; {OBJ/Cafe} {OBJ/Maude;} Abstract State Machines ({ASM)} and Algebraic Methods in Software Technology ({AMAST);} avionics; works-in-progress; industrial experience.},
	language = {en},
	publisher = {Springer},
	author = {Wing, Jeannette M. and Woodcook, Jim and Davies, Jim},
	month = oct,
	year = {1999},
	keywords = {Computers / Computer Science, Computers / Expert Systems, Computers / Programming / General, Computers / Programming Languages / General, Computers / Software Development \& Engineering / General}
},

@article{tarlecki_language_1985,
	title = {A language of specified programs},
	volume = {5},
	issn = {0167-6423},
	url = {http://www.sciencedirect.com/science/article/pii/0167642385900048},
	doi = {10.1016/0167-6423(85)90004-8},
	abstract = {We describe a language of specified programs devised to form a basis for a system for the development of provably-correct programs. A specified program, as introduced by Blikle and then developed in this paper, consists of statements and declarations (in our language these are standard sequential, conditional and loop statements, blocks with local variables and possibly recursive procedures and functions) interleaved with local assertions sufficient to prove the global correctness of the program. This requirement forces us to adopt the philosophy that all the properties of program objects we use in our programs must be explicitly stated in specifications.},
	urldate = {2013-11-11},
	journal = {Science of Computer Programming},
	author = {Tarlecki, Andrzej},
	year = {1985},
	pages = {59--81},
	file = {ScienceDirect Full Text PDF:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/PWTUZ9V6/Tarlecki - 1985 - A language of specified programs.pdf:application/pdf;ScienceDirect Snapshot:/home/alasdair/.mozilla/firefox/wdxjjwzh.default/zotero/storage/B8XD4Z9I/0167642385900048.html:text/html}
}