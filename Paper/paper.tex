\documentclass{llncs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{graphicx,color}
\usepackage{multicol}
\usepackage{bussproofs}
\usepackage{float}
\usepackage{centernot}
\usepackage{marginnote}

\usetikzlibrary{arrows,shapes,calc}

\DeclareFontFamily{U}{wncy}{}
\DeclareFontShape{U}{wncy}{m}{n}{<->wncyss10}{}
\DeclareSymbolFont{mcy}{U}{wncy}{m}{n}
\DeclareMathSymbol{\sh}{\mathord}{mcy}{"78} 
\DeclareMathOperator{\sha}{\sh}
\DeclareMathOperator{\tr}{Tr}
\DeclareMathOperator{\fin}{finite}
\DeclareMathOperator{\rely}{rely}
\DeclareMathOperator{\guar}{guar}
\DeclareMathOperator{\wlp}{wlp}

\newcommand{\udagger}{\text{$\rotatebox[origin=c]{180}{$\dagger$}$}}

\newtheorem{lem}{Lemma}

\begin{document}

\tikzstyle{elem} = [circle]
\tikzstyle{line} = [draw,thick, -latex']
\tikzstyle{rel} = [draw,thin,dashed, -latex']

\title{Algebraic Principles for Concurrency Verification Tools}

\author{Alasdair Armstrong \and Victor B.~F.~Gomes\thanks{Sponsored by CNPq, Brazil}  \and Georg Struth}

\institute{Department of Computer Science, University of Sheffield, UK\\
\email{$\{$a.armstrong,v.gomes,g.struth$\}$@dcs.shef.ac.uk}}

\maketitle

\begin{abstract}
We investigate equational laws for the derivation of rely-guarantee
style, Owicki-Gries style and separation logic style inference and
refinement rules in the minimalistic setting of semirings. The
algebraic level is linked with concrete programming models based on
languages and execution traces. The approach has been implemented in
Isabelle/HOL where the link between algebras and models supports
reasoning about both the control and data flow of concurrent
programs. This is illustrated by simple program verification examples.
\end{abstract}

\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

related work?

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semirings and Kleene Algebra}
\label{sec:KA}

A \emph{semiring} is an structure
$(D,+,\cdot,0,1)$ satisfying the following laws,
\begin{align*}
  x(y + z) &= xy + xz, &\qquad (x + y)z &= xz + yz,\\
  (x + y) + z &= x + (y + z), &\qquad (xy)z &= x(yz),\\
  x + y &= y + x, &\qquad 0 + x &= x,\\
  1x &= x, &\qquad x1 &= x,\\
  0x &= 0, &\qquad x0 &= 0.
\end{align*}
A semiring is \emph{idempotent} if $x + x = x$, and \emph{weak} if $x0
= 0$ does not hold. The natural partial order $\le$ is defined as $x
\le y $ iff $x + y = y$. In an idempotent semiring $(D,+,0)$ therefore
forms a join semilattice with least element $0$. Idempotent semirings
are also called \emph{dioids}. In some contexts, it is also useful to
add a meet operation $\sqcap$, such that $(D,+,\sqcap)$ is a lattice.

In the context of programs, one typically thinks of $\cdot$ as being
sequential composition, $+$ as non-deterministic choice, $0$ as the
abortive action and $1$ as skip. For concurrent software, it is
natural to extend the notion of a dioid to that of a \emph{trioid}
with operators for both sequential and parallel composition. Formally,
a trioid is a structure $(D,+,\cdot,\|,0,1)$ where $(D,+,\cdot,0,1)$
is a dioid and,
\begin{align*}
  x\|(y + z) &= x\|y + x\|z, &\qquad x\|y &= y\|x,\\
  (x\|y)\|z &= x\|(y\|z), &\qquad x\|1 &= x,\\
  0\|x &= x.
\end{align*}

In a trioid there are no laws governing the interaction between
sequential and parallel composition. One law which has been considered
in previous papers is the \emph{exchange} law~\cite{hoare_concurrent_2011,hoare_locality_2011}
\begin{align*}
  (w \| x) \cdot (y \| z) \le (w \cdot z) \| (x \cdot y).
\end{align*}

The exchange law is initially appealing as it provides a way to derive
many properties of parallel composition from a single law. For example
one can show that $\|$ must be commutative, or that $x\cdot y \le
x\|y$. However, there are many interesting models which do not satisfy
this law. First, one could consider fair parallel composition
$x\parallel_f y$ in a model with infinite, or non-terminating
programs. In this model, $x \cdot y \not\leq x \parallel_f y$ in the
case where $x$ is non-terminating. A second example would be
predicate-transformer style models for separation logic, where $\|$ is
interpreted as separating conjunction. In such models, $\|$ and
$\cdot$ have different units, which, in the presence of the exchange
law implies that $\cdot$ is equal to $\|$.

A Kleene algebra~\cite{kozen_completeness_1994} expands a dioid with a star operation satisfying the laws
\begin{align*}
  1 + xx^* &\le x^*, &\qquad z + xy \le y &\implies x^*z \le y,\\
  1 + x^*x &\le x^*, &\qquad z + yx \le y &\implies zx^* \le y.
\end{align*}

For programs, the star represents finite iteration of a program $x$
zero or more times. For iteration where $x$ must be executed at least
once, we write $x^+$. One can similarly axiomatise a parallel star
operation, but in practice this seems to be a less useful operation,
although one could see it as an operator that spawns an arbitrary but
finite number of processes.

A Kleene algebra expanded with a parallel composition operator such
that $(K,+,\cdot,\|,0,1)$ is a trioid in which the exchange law holds
is called a \emph{concurrent Kleene algebra}~\cite{hoare_concurrent_2011}.

In a (concurrent) Kleene algebra Hoare triples can be encoded \`a la
Tarlecki as $\{x\}y\{z\} \iff xy \le z$. Assume residuals axiomatised
by Galois connections
\begin{align*}
 x \le z \leftarrow y \iff xy \le z \iff y \le x \rightarrow z,
\end{align*}
exist, as in Pratt's \emph{action
  algebra}~\cite{pratt_action_1990}. Then the Hoare triple
$\{x\}y\{z\}$ is equivalent to $x \le z \leftarrow y$, where $z
\leftarrow y$ can be seen as $\wlp(y,z)$.

For sequential programs, Hoare logic can also be encoded algebraically by
expanding a Kleene algebra with a Boolean test subalgebra. A
\emph{Kleene algebra with tests} (KAT)~\cite{kozen_kleene_1997} is structure
$(K,B,+,\cdot,\phantom{|}^\star,\overline{\phantom{x}},0,1)$ where
$(K,+,\cdot,\phantom{|}^\star,0,1)$ is a Kleene algebra and
$(B,+,\cdot,\overline{\phantom{x}},0,1)$ is a Boolean algebra such
that $B \subseteq K$. The $\overline{\phantom{x}}$ operator is only
defined on elements of the Boolean subalgebra. We denote arbitrary
elements of $K$ by $x,y,z$ and tests by $p,q,r$.

In KAT Hoare triples are defined in the following (equivalent) ways
\begin{align*}
\{p\}x\{q\} \iff px \le xq \iff px = pxq \iff px\overline{q} = 0.
\end{align*}
Using these encodings all the rules of Hoare logic excluding the
assignment rule can be derived.

One might be tempted to add a test subalgbra to concurrent Kleene
algebra in the style of KAT. In such an algebra, can the Kozen-style
encoding of hoare triples above can be used to derive Owicki-Gries
style concurrency rules? The answer seems to be no---an algebraic
approach imposes strong compositionality requirements (a point we will
return to later), so it should come as no suprise that a
non-compositional method such as Owicki-Gries cannot be so easily be
done algebraically.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algebra for Rely-Guarantee}
\label{sec:RG}

Define a rely-guarantee algebra as a structure
$(K,RG,+,\sqcap,\cdot,\|,^\star,0,1)$, where $(K,+,\sqcap)$ is a
lattice, $(K,+,\cdot,\|,0,1)$ is a weak trioid and
$(K,+,\cdot,^\star,0,1)$ is a Kleene algebra. $RG$ is a distinguished
subset of relys and guarantees which satisfy the following axioms
\begin{align}
r\|r &\le r, \label{rg1}\\
r &\le r\|r', \label{rg2}\\
r\|xy &= (r\|x)(r\|y), \label{rg3}\\
r\|x^+ &\le (r\|x)^+ \label{rg4}.
\end{align}
By convention, we use $r$ and $g$ to refer to elements of $RG$, and
$x,y,z$ for arbitrary elements of $K$. Some elementary consequences of these rules are as follows
\begin{align*}
1 &\le r,\\
r^\star = rr &= r = r\|r,\\
r\|x^+ &= (r\|x)^+.
\end{align*}

%% Could use better explanations.

Axiom (\ref{rg1}) states that interference from a rely condition being
run twice in parallel is no different from just the interference from
that rely condition begin run once in parallel. Axiom (\ref{rg2})
states that interference from a single rely condition is less than
interference from itself and another rely condition. Axiom (\ref{rg3})
allows a rely or guarantee to be split across sequential
programs. Axiom (\ref{rg4}) is similar to Axiom (\ref{rg3}) in intent,
except it deals with finite iteration.

Axioms (\ref{rg1}), (\ref{rg2}) and (\ref{rg3}) are independent. To
show this, we use Isabelle's
\emph{Nitpick}~\cite{blanchette_nitpick:_2010} counterexample generator
to construct models which violate each of these axioms, yet satisfy
all others. The models thus constructed for (\ref{rg1}) and
(\ref{rg3}) are shown in Figures \ref{fig:rg1} and \ref{fig:rg3}
respectively. The model constructed for (\ref{rg2}) is just the two
element rely-guarantee algebra with $0$ and $1$.

\begin{figure}[H]
\centering
\begin{minipage}{0.24\textwidth}
\begin{tikzpicture}[x=1.5cm,y=1.5cm,auto]
  \node (center) {};
  \node [elem] (r1) at (90:1) {$r_1$};
  \node [elem] (one) at (200:1) {$1$};
  \node [elem] (r2) at (20:1) {$r_2$};
  \node [elem] (zero) at (-90:1) {$0$};

  \path [line] (r1) -- (r2);
  \path [line] (r1) -- (one);
  \path [line] (r1) -- (zero);
  \path [line] (r2) -- (one);
  \path [line] (r2) -- (zero);
  \path [line] (one) -- (zero);
\end{tikzpicture}
\end{minipage}
\begin{minipage}{0.24\textwidth}
\begin{align*}
r_1 \| r_1 &= r_1\\
r_1 \| r_2 &= r_1\\
r_2 \| r_1 &= r_1\\
r_2 \| r_2 &= r_1
\end{align*}
\end{minipage}
\begin{minipage}{0.24\textwidth}
\begin{align*}
r_1r_1 &= r_1\\
r_1r_2 &= r_1\\
r_2r_1 &= r_1\\
r_2r_2 &= r_2
\end{align*}
\end{minipage}
\begin{minipage}{0.24\textwidth}
\begin{align*}
r_1^\star &= r_1\\
r_2^\star &= r_2
\end{align*}
\end{minipage}
\caption{4 element counterexample for $r \in RG \implies r\|r \le r$}
\label{fig:rg1}
\end{figure}

Axiom (\ref{rg4}) can be derived from (\ref{rg3}) in all finite
models. This is because any finite $K$ is complete, and in a complete
setting fixpoint laws can be used to show $r\|x^+ \le (r\|x)^+$. Thus
it is impossible to construct a finite model demonstrating that
(\ref{rg4}) is independent from (\ref{rg1}) -- (\ref{rg2}).

\begin{figure}[t]
\centering
\begin{minipage}{0.24\textwidth}
\begin{tikzpicture}[x=1.5cm,y=1.5cm,auto]
  \node (center) {};
  \node [elem] (r1) at (90:1) {$r_1$};
  \node [elem] (one) at (0:1) {$1$};
  \node [elem] (zero) at (-90:1) {$0$};

  \path [line] (r1) -- (one);
  \path [line] (r1) -- (zero);
  \path [line] (r1) -- (zero);
  \path [line] (one) -- (zero);
\end{tikzpicture}
\end{minipage}
\begin{minipage}{0.24\textwidth}
\begin{align*}
r_1 \| r_1 &= r_1\\
r_1 r_1 &= r_1\\
r_1^\star &= r_1
\end{align*}
\end{minipage}
\caption{3 element counterexample for $r \in RG \implies r\|xy = (r\|x)(r\|y)$}
\label{fig:rg3}
\end{figure}

Jones quintuples can be encodeded in this setting as
\begin{align}
r, g \vdash \{p\} c \{q\} \iff p(r\|c) \le q \land c \le g. \label{quin}
\end{align}
With this encoding we can derive the standard rely-guarantee inference
rules, as shown in Figure \ref{fig:rgrules}. Thus equations
(\ref{rg1}) to (\ref{rg4}), which are all necessary to derive these
rules, somehow represent a minimal set of axioms from which these
inference rules can be derived.

We can expand our rely-guarantee algebras to have residuals
axiomatised by Galois connections for both parallel and sequential
composition, i.e.
\begin{align}
xy \le z &\iff y \le x \rightarrow z, \label{res1}\\
xy \le z &\iff x \le z \leftarrow y, \label{res2}\\
x\|y \le z &\iff y \le x/z \label{res3}.
\end{align}
For sequential composition, (\ref{res1}) and (\ref{res2}) essentially
provide a link between weakest-precondition style semantics and hoare
logic. As mentioned in Section \ref{sec:KA}, the triple $\{p\} c
\{q\}$ can be encoded as $pc \le q$, while $q \leftarrow c$ represents
$wlp(c,q)$. Equation (\ref{res2}) can thus be written as $\{p\} c
\{q\} \iff p \le wlp(c,q)$. The parallel residual $x/z$ can be
understood similarly as follows; it is the weakest program such that
when placed in parallel with $x$, the composition behaves as $z$.

By using residuals quintuples can be encoded in the following way,
which is equivalent to the encoding in Equation (\ref{quin}).
\begin{align}
r, g \vdash \{p\} c \{q\} \iff c \le r/(p \rightarrow q) \sqcap g \label{refine}.
\end{align}
This encoding allows us to think in terms of program refinement, as
$r/(p \rightarrow q) \sqcap g$ defines the weakest program that when
placed in parallel with interference from $r$, and guaranteeing
interference at most $g$, goes from $p$ to $q$---which is essentially
a generic specification for a concurrent program.

\begin{figure}[tbh]
\centering
\begin{prooftree}
\RightLabel{Skip}
\AxiomC{$pr \le p$}
\UnaryInfC{$r, g \vdash \{p\}1\{p\}$}
\end{prooftree}

\begin{prooftree}
\RightLabel{Weakening}
\AxiomC{$r' \le r$}
\AxiomC{$g \le g'$}
\AxiomC{$p \le p'$}
\AxiomC{$r', g' \vdash \{p'\}x\{q'\}$}
\AxiomC{$q' \le q$}
\QuinaryInfC{$r, g \vdash \{p\}x\{q\}$}
\end{prooftree}

\begin{prooftree}
\RightLabel{Sequential}
\AxiomC{$r, g \vdash \{p\}x\{q\}$}
\AxiomC{$r, g \vdash \{q\}y\{s\}$}
\BinaryInfC{$r, g \vdash \{q\}xy\{s\}$}
\end{prooftree}

\begin{prooftree}
\RightLabel{Parallel}
\AxiomC{$r_1, g_2 \vdash \{p_1\}x\{q_1\}$}
\AxiomC{$g_1 \le r_2$}
\AxiomC{$r_1, g_2 \vdash \{p_2\}y\{q_2\}$}
\AxiomC{$g_2 \le r_1$}
\QuaternaryInfC{$r_1 \sqcap r_2, g_1 \| g_2 \vdash \{p_1 \sqcap q_2\}x\|y\{q_1 \sqcap q_2\}$}
\end{prooftree}

\begin{prooftree}
\RightLabel{Choice}
\AxiomC{$r, g \vdash \{p\}x\{q\}$}
\AxiomC{$r, g \vdash \{p\}y\{q\}$}
\BinaryInfC{$r, g \vdash \{p\}x + y\{q\}$}
\end{prooftree}

\begin{prooftree}
\RightLabel{Star}
\AxiomC{$pr \le p$}
\AxiomC{$r, g \vdash \{p\}x\{p\}$}
\BinaryInfC{$r, g \vdash \{p\}x^\star\{p\}$}
\end{prooftree}
\caption{Rely-guarantee inference rules}
\label{fig:rgrules}
\end{figure}

% Or should this be weak?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Breaking Compositionality}
\label{sec:INT}

While the algebra in section \ref{sec:RG} is adequate for deriving the
standard inference rules, the equality is too strong to capture many
interesting statements about concurrent programs. Consider the
congruence rule for parallel composition, which is inherent in the
algebraic approach:
\begin{align*}
x = y \implies x\|z = y\|z.
\end{align*}
This can be read as follows; if $x$ and $y$ are equal, then they must
be equal under all possible interference from any arbitrary $z$. At
first glance this might seem to preclude any reasoning about
interference in a fine-grained way using only algebra. This is not the
case, but breaking such inherent compositionality in just the right way to
capture interesting properties of interference requires some extra work.

The most obvious way we can acheive this is by simply expanding our
rely-guarantee algebra with an arbitrary function $f$. And redefining our quintuples
as,
\begin{align*}
r, g \vdash \{p\} c \{q\} \iff f(p(r\|c)) \le f(q) \land c \le g.
\end{align*}


 but we can work around this by
using an \emph{interior operator}. In a rely-guarantee algebra an
interior operator is any function $f : K \to K$ which satisfies
\begin{align*}
f(f(x)) &= f(x) \tag{$f$ is idempotent}\\
x \le y \implies f(x) &\le f(y) \tag{$f$ is isotone}\\
f(x) &\le x \tag{$f$ is coextensive}
\end{align*}

We extend our rely-guarantee algebra to
$(K,RG,+,\cdot,\|,^\star,[\--],0,1)$ by adding a single interior
operator $[\--]$, which additionally satisfies
\begin{align}
[xy] &= [x][y], \label{rgimult}\\
[x + y] &= [x] + [y],\\
[x \sqcap y] &= [x] \sqcap [y],\\
[x^\star] &= [x]^\star,\\
[0] &= 0 \label{rgi0}
\end{align}
Intuitively $[x]$ can be thought of as the \emph{execution} of a
program $x$. While $x$ contains all information about what the process
or program \emph{could} do, $[x]$ only contains information about what
it \emph{actually} does. Note that (\ref{rgimult}) -- (\ref{rgi0}) do
not mention parallel composition, such that in general $[x] = [y]
\centernot\implies [x\|z] = [y\|z]$. We amend our jones-quintuples to
involve this operator as shown below.
\begin{align*}
r,g \vdash \{p\} c \{q\} \iff p[r\|c] \le q \land c \le g.
\end{align*}
All the rules in Figure \ref{fig:rgrules} can be derived with this
encoding, and moreover their proofs remain the same, mutatis
mutandis.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algebra for Separation Logic}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finite Language Model}
\label{sec:Model}

In this section, we construct a finite language model satisfying the
axioms in Section \ref{sec:RG}. Restricting our attention to finite
languages means we do not need to concern ourselves with non-algebraic
termination side-conditions, nor do we need to worry about additional
restrictions on parallel composition, e.g. fairness. However, all the
results in this section can easily be adapted to potentially
infinite languages, and our Isabelle/HOL formalisation includes these more
general definitions by using coinductively defined lazy lists to
represent words, and having a weakly-fair shuffle operator for such
infinite languages.

As usual, the product of two languages X and Y over an alphabet
$\Sigma$ is defined as $XY = \{x\frown y.\; x \in X \land y \in Y\}$.
The language product is associative, and distributes over arbitrary
joins from both the left and the right, i.e.
\begin{align*}
X(\bigcup Y) = \bigcup\{XZ.\; Z \in Y\} \qquad \text{and} \qquad (\bigcup Y)X = \bigcup\{ZX.\; Z \in Y\}.
\end{align*}
The shuffle $\sha$ on a pair
of finite words is defined inductively as
\begin{align*}
\epsilon \sha s = \{s\}, \qquad s \sha \epsilon = \{s\},\\
as \sha bt = a(s \sha bt) \cup b(as \sha t),
\end{align*}
which is then lifted to languages X and Y as the shuffle product,
\begin{align*}
X \sha Y = \bigcup\{xs \sha ys.\; x \in X \land x \in Y\}.
\end{align*}
The shuffle product is associative, commutative, and distributes over
arbitrary joins. Both products share the same unit, $\{\epsilon\}$ and
zero, $\emptyset$. Proving properties of shuffle is suprisingly
tricky (especially if one considers infinite words). For a in-depth
treatment of the shuffle product see~\cite{shufflethings}. The
above properties are enough to show that $(\mathcal{P}(\Sigma)^*),
\cup, \cdot,\sha, \emptyset, \{\epsilon\})$ forms a weak trioid.

The rely-guarantee elements in this model are sets containing all the
words which can be built from some set of actions in $\Sigma$. We can
consider a function $\rely : \mathcal{P}(\Sigma) \to
\mathcal{P}(\Sigma)^*$ which takes a set of actions and returns all
the words that can be built from them. This function is an upper
adjoint for $\guar$, the function which returns all the letters in a
language.
\begin{align*}
\guar(X) \le Y \iff X \le \rely(Y)
\end{align*}

Properties (\ref{rg1}) and (\ref{rg2}) from Section \ref{sec:RG} can
mostly be derived from basic properties of $\rely$. Namely,
\begin{align*}
\rely(X \cup Y) &= \rely(X) \| \rely(Y),\\
\qquad \rely(X \cap Y) &= \rely(X) \cap \rely(Y).
\end{align*}
The proofs of (\ref{rg3}) and (\ref{rg4}) are somewhat more involved,
but ultimately rather mechanical, so we do not show them here. We
define the set $RG$ of rely-guarantee elements as the range of the
$\rely$ function and therefore are able to show that $(\mathcal{P}(\Sigma)^*), RG, \cup,
\cdot,\sha, \emptyset, \{\epsilon\})$ is a rely-guarantee algebra.

To make our model more concrete we consider an alphabet comprising
relations ($R,S,T,\dots$) over a state space $\Sigma$. A single
relation represents a single atomic action of a program. Assuming
$\Sigma = \{\sigma_1,\sigma_2,\sigma_3\}$, an example of a word in
$(\Sigma^2)^*$ is shown below.

\begin{center}
\begin{tikzpicture}[x=1cm,auto]
  \node (center) {};
  \node [elem] (s12) {$\sigma_2$};
  \node [elem, above of=s12] (s11) {$\sigma_1$};
  \node [elem, below of=s12] (s13) {$\sigma_3$};
  \node [right of=s13, node distance=0.75cm] (r1) {};
  \node [below of=r1, node distance=0.5cm] (t4) {R};

  \node [elem, right of=s12, node distance=1.5cm] (s22) {$\sigma_2$};
  \node [elem, above of=s22] (s21) {$\sigma_1$};
  \node [elem, below of=s22] (s23) {$\sigma_3$};
  \node [right of=s23, node distance=0.75cm] (r2) {};
  \node [below of=r2, node distance=0.5cm] (t4) {S};

  \node [elem, right of=s22, node distance=1.5cm] (s32) {$\sigma_2$};
  \node [elem, above of=s32] (s31) {$\sigma_1$};
  \node [elem, below of=s32] (s33) {$\sigma_3$};
  \node [right of=s33, node distance=0.75cm] (r3) {};
  \node [below of=r3, node distance=0.5cm] (t4) {T};

  \node [elem, right of=s32, node distance=1.5cm] (s42) {$\sigma_2$};
  \node [elem, above of=s42] (s41) {$\sigma_1$};
  \node [elem, below of=s42] (s43) {$\sigma_3$};
  \node [right of=s43, node distance=0.75cm] (r4) {};
  \node [below of=r4, node distance=0.5cm] (t4) {U};

  \node [elem, right of=s42, node distance=1.5cm] (s52) {$\sigma_2$};
  \node [elem, above of=s52] (s51) {$\sigma_1$};
  \node [elem, below of=s52] (s53) {$\sigma_3$};

  \path [line] (s11) -- (s21);
  \path [line] (s21) -- (s32);
  \path [line] (s32) -- (s43);
  \path [line] (s43) -- (s52);

  \path [rel] (s11) -- (s22);
  \path [rel] (s12) -- (s22);
  \path [rel] (s23) -- (s32);
  \path [rel] (s32) -- (s42);
  \path [rel] (s42) -- (s51);
  \path [rel] (s41) -- (s52);
\end{tikzpicture}
\end{center}

This word only has a single valid \emph{trace}, which is
$\sigma_1\rightarrow\sigma_1\rightarrow\sigma_2\rightarrow\sigma_3\rightarrow\sigma_2$.
Such state transition traces are commonly called \emph{Aczel
  traces}~\cite{Aczel}. Note that unlike much of the literature involving
Aczel-style traces for concurrency, we omit any kind of process or
environment labelling from our transitions. We define an operator
$\tr(X)$ which returns all such traces in a language $X$. $\tr$ is
both idempotent and isotone.

Note that we cannot use the shuffle operator on directly traces. For
example, imagine we shuffled the single transition $\sigma_2 \to
\sigma_3$ into the above word, we could end up with a word as below.

\begin{center}
\begin{tikzpicture}[x=1cm,auto]
  \node [elem] (s12) {$\sigma_2$};
  \node [elem, above of=s12] (s11) {$\sigma_1$};
  \node [elem, below of=s12] (s13) {$\sigma_3$};
  \node [right of=s13, node distance=0.75cm] (r1) {};
  \node [below of=r1, node distance=0.5cm] (t4) {R};

  \node [elem, right of=s12, node distance=1.5cm] (i2) {$\sigma_2$};
  \node [elem, above of=i2] (i1) {$\sigma_1$};
  \node [elem, below of=i2] (i3) {$\sigma_3$};
  \node [right of=i3, node distance=0.75cm] (ri) {};
  \node [below of=ri, node distance=0.5cm] (ti) {V};

  \node [elem, right of=i2, node distance=1.5cm] (s22) {$\sigma_2$};
  \node [elem, above of=s22] (s21) {$\sigma_1$};
  \node [elem, below of=s22] (s23) {$\sigma_3$};
  \node [right of=s23, node distance=0.75cm] (r2) {};
  \node [below of=r2, node distance=0.5cm] (t4) {S};

  \node [elem, right of=s22, node distance=1.5cm] (s32) {$\sigma_2$};
  \node [elem, above of=s32] (s31) {$\sigma_1$};
  \node [elem, below of=s32] (s33) {$\sigma_3$};
  \node [right of=s33, node distance=0.75cm] (r3) {};
  \node [below of=r3, node distance=0.5cm] (t4) {T};

  \node [elem, right of=s32, node distance=1.5cm] (s42) {$\sigma_2$};
  \node [elem, above of=s42] (s41) {$\sigma_1$};
  \node [elem, below of=s42] (s43) {$\sigma_3$};
  \node [right of=s43, node distance=0.75cm] (r4) {};
  \node [below of=r4, node distance=0.5cm] (t4) {U};

  \node [elem, right of=s42, node distance=1.5cm] (s52) {$\sigma_2$};
  \node [elem, above of=s52] (s51) {$\sigma_1$};
  \node [elem, below of=s52] (s53) {$\sigma_3$};

  \path [rel] (s11) -- (i1);
  \path [rel] (s21) -- (s32);
  \path [line] (s32) -- (s43);
  \path [line] (s43) -- (s52);
  \path [line] (i2) -- (s23);

  \path [rel] (s11) -- (i2);
  \path [line] (s12) -- (i2);
  \path [line] (s23) -- (s32);
  \path [line] (s32) -- (s42);
  \path [line] (s42) -- (s51);
  \path [rel] (s41) -- (s52);
\end{tikzpicture}
\end{center}

By performing this shuffle action, we no longer have a trace from
$\sigma_1$ to $\sigma_2$, but instead two traces from $\sigma_2$ to
$\sigma_2$ and $\sigma_3$. This subtle interplay between shuffle and
$\tr$ mimics how Aczel-traces are typically generated from an
operational semantics in much existing rely-guarantee literature. This
operational approach is not desireable from an algebraic perspective
though, as we would rather see programs as mathematical objects in
their own right---a more denotational approach.

Following~\cite{brookes_full_1993} and~\cite{dingel_refinement_2002},
we inductively generate the stutter/mumble language $w^\dagger$ for a
word $w$ in a language over $\Sigma^2$ as follows: Assume $R,S,T \in
\Sigma^2$ and $u,v,w \in (\Sigma^2)^*$. First, $Iw \in
w^\dagger$. Secondly, if $uRv \in x^\dagger$ then $uIRv \in
x^\dagger$ and $uRIv \in x^\dagger$ (\emph{stuttering}). Thirdly, if
$uRSv \in w^\dagger$ then $u(R;S)v \in w^\dagger$
(\emph{mumbling}). The stutter/mumble closure of a language is
thus defined by lifting this operation to languages.
\begin{align*}
X^\dagger = \bigcup\{x^\dagger.\; x \in X\}
\end{align*}

Next, we define the following language for a word $w = R_0R_1\dots
R_n$. The language $w^\udagger$ contains all strings $S_0S_1\dots S_n$
such that for all $m \le n$, $S_m \subseteq R_m$. Effectively this
gives us all the words which are less that $w$ pointwise. Again this
operation is lifted to languages in the same way as before. We define
the set of \emph{$smp$-closed} languages by combining both these
closure operators into a single closure operator, $X^\ddagger$, which
satisfies the properties
\begin{align}
(X^\ddagger \sha Y)^\ddagger &= (X \sha Y)^\ddagger,\\
(X^\ddagger Y)^\ddagger = (&XY)^\ddagger = (XY^\ddagger)^\ddagger,\\
(X \cup Y)^\ddagger &= (X^\ddagger \cup Y^\ddagger),\\
(X^\ddagger \cap Y^\ddagger)^\ddagger &= (X^\ddagger \cap Y^\ddagger),\\
\tr(X^\ddagger) &\subseteq X^\ddagger. \label{trcoext}
\end{align}
These five properties essentially allow us to `lift' all our operators
from above to act on $smp$-closed languages in such a way that they
still form a weak trioid. Henceforth, we will assume all our languages are
$smp$-closed, and all operators have been appropriately lifted.

Equation (\ref{trcoext}) shows that $\tr$ is now an interior operator
on the set of $smp$-closed languages.

We now consider how tests are represented in this model, we define
$\langle R\rangle$ as the singleton language containing just the
relation $R$. Tests are defined as traces of the form $\langle
R\rangle^\ddagger$ where $R \subseteq I$. We denote the set of all
tests as $B$, and let it be ranged over by $P,Q,S$. From the
definition of $smp$-closure $\langle I\rangle^\ddagger =
\{\epsilon\}^\ddagger$, thus the greatest test is $1$, while the least
test is $\langle \emptyset\rangle^\ddagger$, $0$. As such our tests
form a boolean algebra between $1$ and $0$, much they would in
Kozen's Kleene algebra with tests.

\begin{center}
\begin{tikzpicture}[x=1cm,auto]
  \node (center) {};
  \node [elem] (s12) {$\sigma_2$};
  \node [elem, above of=s12] (s11) {$\sigma_1$};
  \node [elem, below of=s12] (s13) {$\sigma_3$};
  \node [right of=s13, node distance=0.75cm] (r1) {};
  \node [below of=r1, node distance=0.5cm] (t4) {$R$};

  \node [elem, right of=s12, node distance=1.5cm] (s22) {$\sigma_2$};
  \node [elem, above of=s22] (s21) {$\sigma_1$};
  \node [elem, below of=s22] (s23) {$\sigma_3$};
  \node [right of=s23, node distance=0.75cm] (r2) {};
  \node [below of=r2, node distance=0.5cm] (t4) {$R$};

  \node [elem, right of=s22, node distance=1.5cm] (s32) {$\sigma_2$};
  \node [elem, above of=s32] (s31) {$\sigma_1$};
  \node [elem, below of=s32] (s33) {$\sigma_3$};

  \node [elem, right of=s32, node distance=1.5cm] (s42) {$\sigma_2$};
  \node [elem, above of=s42] (s41) {$\sigma_1$};
  \node [elem, below of=s42] (s43) {$\sigma_3$};
  \node [right of=s43, node distance=0.75cm] (r4) {};
  \node [below of=r4, node distance=0.5cm] (t4) {$R$};

  \node [elem, right of=s42, node distance=1.5cm] (s52) {$\sigma_2$};
  \node [elem, above of=s52] (s51) {$\sigma_1$};
  \node [elem, below of=s52] (s53) {$\sigma_3$};
  \node [right of=s53, node distance=0.75cm] (r5) {};
  \node [below of=r5, node distance=0.5cm] (t5) {$\lnot R$};

  \node [elem, right of=s52, node distance=1.5cm] (s62) {$\sigma_2$};
  \node [elem, above of=s62] (s61) {$\sigma_1$};
  \node [elem, below of=s62] (s63) {$\sigma_3$};

  \path [line] (s11) -- (s21);
  \path [line] (s12) -- (s22);
  \path [line] (s21) -- (s31);
  \path [line] (s22) -- (s32);

  \path [rel] (s42) -- (s52);
  \path [rel] (s41) -- (s51);
  \path [rel] (s53) -- (s63);
\end{tikzpicture}
\end{center}

A key difference however is that tests only behave as tests when under
$\tr$. This is illustrated above---$\tr(\langle R\rangle^\ddagger\langle
R\rangle^\ddagger) = \tr(\langle R\rangle^\ddagger)$ while $\tr(\langle
R\rangle^\ddagger\langle \lnot R\rangle^\ddagger) = 0$.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\bibliography{paper}{}
\bibliographystyle{plain}

\end{document}
